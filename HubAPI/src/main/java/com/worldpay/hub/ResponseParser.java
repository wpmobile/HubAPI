package com.worldpay.hub;
import android.util.Log;

import com.worldpay.hub.commands.Command;
import com.worldpay.hub.link.Envelope;
import com.worldpay.hub.usbserial.util.HexDump;

import java.nio.ByteBuffer;

/**
 * Deserialise a response into a queryable class.
 */
public class ResponseParser
{
    public static final int STX = 0x02;
    public static final int DLE = 0x10;

    public int mFrameLength;
    public int mCurrentLength;

    protected static final int STATE_START          = 0;
    protected static final int STATE_LENGTH         = 1;
    protected static final int STATE_ADDRESS        = 2;
    protected static final int STATE_SOURCE         = 3;
    protected static final int STATE_TAG            = 4;
    protected static final int STATE_COMMAND_CODE   = 5;
    protected static final int STATE_COMMAND_DATA   = 6;
    protected static final int STATE_CHECKSUM       = 7;

    protected int mExpectedState = STATE_START;

    protected Envelope mCurrentEnvelope;
    protected Command mCurrentCommand;
    protected ByteBuffer mCommandData;

    private static final boolean SUPPORT_MULTI_FRAME = false;

    /**
     * Extracts Envelopes from Frames
     * @param data
     */
    public Envelope process(byte[] data)
    {
        //This is a finite state machine, there are not very many states.
        //We're going to process the data byte-by-byte
        //STX - Flush any current data as a new frame and start a fresh one

        //Its important that this method is not initialised when called, state must be
        //maintained between calls.

     //   Log.d("MePOS", "Raw data follows");
     //   Log.d("MePOS", HexDump.dumpHexString(data, 0, data.length));
        byte[] unescapedData = unescape(data);

     //   Log.d("MePOS", "Unescaped data follows");
     //   Log.d("MePOS", HexDump.dumpHexString(unescapedData, 0, unescapedData.length));

        //Validate the checksum
        if(!validate(unescapedData))
            return null;

        startNewFrame();
        for(byte b : unescapedData)
        {
            if(mExpectedState == STATE_START && b == STX)
            {
                //Header byte, we've already unescaped, so we might hit other STX bytes in the data
                //now.  That's completely valid
                mExpectedState = STATE_LENGTH;
            }
            else if(mExpectedState == STATE_LENGTH) {
                addLength(b);
            }
            else {
                switch (mExpectedState) {

                    case STATE_ADDRESS:
                        if (mCurrentEnvelope != null) {
                            mCurrentEnvelope.setAddress(b);
                            mExpectedState = STATE_SOURCE;
                        }
                        break;
                    case STATE_SOURCE:
                        if (mCurrentEnvelope != null) {
                            mCurrentEnvelope.setSource(b);
                            mExpectedState = STATE_COMMAND_CODE;
                        }
                        break;
                    case STATE_COMMAND_CODE:
                        mCurrentCommand = Command.getCommand((char)b);
                        mExpectedState = STATE_TAG;
                        break;
                    case STATE_TAG:
                        if (mCurrentEnvelope != null) {
                            mCurrentEnvelope.setTag(b);
                            mExpectedState = STATE_COMMAND_DATA;
                        }
                        break;
                    case STATE_COMMAND_DATA:
                        addCommandData(b);
                        break;
                    case STATE_CHECKSUM:
                        //Do nothing, already validated
                        break;
                }

                mCurrentLength++;

                if(mCurrentLength == mFrameLength)
                {
                    //We've read the expected data
                    mExpectedState = STATE_CHECKSUM;
                }
            }
        }

        mCurrentCommand.setCommandData(mCommandData.array());
        mCurrentEnvelope.setCommand(mCurrentCommand);
        return mCurrentEnvelope;
    }

    protected void addCommandData(byte b)
    {
        mCommandData.put(b);
    }

    protected boolean validate(byte[] data)
    {
        int len = data.length;
        byte[] validateData = new byte[len - 2];
        System.arraycopy(data, 0, validateData, 0, len - 2);
        int crc = Checksum.generate(validateData);

        Log.d("MePOS", String.format("I reckon the checksum should be %04X", crc));

        //The last two bytes make the checksum we need to compare
        int testCrc = (byte)(data[len - 2] & 0xFF);
        testCrc = testCrc << 8;
        testCrc += (byte)(data[len - 1] & 0xFF);
        testCrc = testCrc & 0xFFFF;
        Log.d("MePOS", String.format("The data has a checksum of %02X%02X",
                            data[len - 2] & 0xFF, data[len - 1] & 0xFF));

        return (crc == testCrc);
    }

    protected void startNewFrame()
    {
        mCurrentEnvelope = new Envelope();
        mCurrentCommand = new Command();
        mFrameLength = 0;
        mCurrentLength = 0;
        mExpectedState = STATE_START;
    }

    protected void addLength(byte b)
    {
        if(mFrameLength == 0 && ((b & 0x80) == 0x80))
        {
            mFrameLength = b & (byte)0x7F; //Mask out bit 7
            //Don't change the state marker
        }
        else
        {
            //TODO:  This doesn't calculate the length for responses > 127 bytes correctly
            //Only expecting one byte, or it is the second byte
            mFrameLength += b;
            mExpectedState = STATE_ADDRESS;
            mCommandData = ByteBuffer.allocate(mFrameLength - 4);
        }
    }

    protected byte[] unescape(byte[] data)
    {
        //First pass - determine length
        int len = 1;

        for(int i = 1; i < data.length; i++)
        {
            if (data[i] != DLE)
            {
                len++;
            }
        }

        Log.d("MePOS", String.format("Raw data is %d bytes, unescaped %d", data.length, len));

        ByteBuffer buffer = ByteBuffer.allocate(len);
        buffer.put(data[0]);

        //Second pass, copy data
        //init of i = 1 is deliberate.  don't escape the first byte (STX)
        boolean flipByte = false;
        for(int i = 1; i < data.length; i++)
        {
            if(data[i] == DLE)
            {
                flipByte = true;
            }
            else
            {
                byte b = data[i];
                if(flipByte)
                    b = (byte)(b & 0xBF);
                buffer.put(b);
                flipByte = false;
            }
        }

        return buffer.array();
    }
}
